### 1. DOM (Document Object Model)

Когда веб-страница загружается в браузер, создаётся объектная модель документа (DOM), которая представляет HTML как дерево объектов. JavaScript может манипулировать этим деревом, получая доступ к любому элементу и изменяя его.

Пример HTML-документа:

```
<!DOCTYPE html>
<html> 
<head>   
	<title>Взаимодействие с JavaScript</title> 
</head> 
<body>    
	<h1 id="heading">Привет, мир!</h1> 
	<p class="text">Это параграф текста.</p>   
	<button onclick="changeText()">Нажми меня</button>  
	<script>     // Здесь будет код JavaScript   </script>  
</body> 
</html>
```

### 2. Как обращаться к элементам HTML через JavaScript?

Чтобы начать работать с элементами на странице, JavaScript предоставляет несколько методов для их поиска.

#### 2.1 Поиск элемента по ID

ID должен быть уникальным на странице, и это один из самых простых способов найти элемент:

```
let heading = document.getElementById('heading'); 
console.log(heading.textContent);  // Выведет текст "Привет, мир!"`
```

- **`textContent`** — свойство, которое возвращает или задаёт текст внутри элемента.

#### 2.2 Поиск элементов по классу

Если на странице несколько элементов с одинаковым классом, их можно получить с помощью метода `getElementsByClassName`. Это вернёт коллекцию (массивоподобный объект) элементов:

```
let paragraphs = document.getElementsByClassName('text'); 
console.log(paragraphs[0].textContent);  // Выведет текст первого параграфа
```

#### 2.3 Поиск элементов по тегу

Можно искать элементы по тегу, например, все `<p>`:

```
let paragraphs = document.getElementsByTagName('p'); 
console.log(paragraphs.length);  // Выведет количество параграфов на странице
```
#### 2.4 Использование `querySelector` и `querySelectorAll`

Эти методы позволяют использовать CSS-селекторы для поиска элементов. Они более гибкие, чем предыдущие методы:

```
let heading = document.querySelector('#heading');  // Найдёт элемент по ID let 
paragraphs = document.querySelectorAll('.text');  // Найдёт все элементы с классом "text"`
```

- `querySelector` возвращает **первый найденный элемент**.
- `querySelectorAll` возвращает **все элементы** в виде коллекции.

### 3. Изменение содержимого и атрибутов элементов

#### 3.1 Изменение текста

Вы можете изменить текст внутри элемента с помощью свойства `textContent`:


```
let heading = document.getElementById('heading');` 
heading.textContent = 'Новый заголовок';
```

#### 3.2 Изменение HTML внутри элемента

Свойство `innerHTML` позволяет задать HTML-код внутри элемента:


```
let paragraph = document.querySelector('.text'); 
paragraph.innerHTML = '<strong>Изменённый</strong> текст';
```

> **Важно:** Изменяя `innerHTML`, JavaScript может перезаписать существующий HTML-контент внутри элемента, поэтому используйте его осторожно.

#### 3.3 Изменение атрибутов

Атрибуты HTML-элементов (например, `src`, `href`, `class`) можно изменить с помощью метода `setAttribute` или напрямую через свойства:

```
// Изменение атрибута 
let image = document.querySelector('img'); 
image.setAttribute('src', 'new-image.jpg');  
// Либо напрямую image.src = 'new-image.jpg';
```

### 4. Изменение стилей элементов

JavaScript может изменять стили элемента через свойство `style`. Каждый стиль можно установить как отдельное свойство объекта:

```
let heading = document.getElementById('heading'); 
heading.style.color = 'red';  // Изменит цвет текста на красный 
heading.style.fontSize = '30px';  // Изменит размер шрифта
```

Для сложных манипуляций со стилями лучше использовать добавление/удаление классов через `classList`:

```
let heading = document.getElementById('heading'); 
heading.classList.add('highlight');  // Добавит класс к элементу 
heading.classList.remove('highlight');  // Удалит класс
```

### 5. Работа с событиями

События позволяют реагировать на действия пользователя, такие как клики, ввод текста или загрузка страницы. Для этого можно использовать атрибуты событий прямо в HTML или добавить слушатели событий с помощью JavaScript.

#### 5.1 Обработка событий через атрибуты HTML

Пример использования атрибута `onclick`:

`<button onclick="changeText()">Нажми меня</button>`

Функция `changeText`, которая вызывается при клике:

```
function changeText() {   
	let heading = document.getElementById('heading');   
	heading.textContent = 'Текст изменён!'; 
}
```

#### 5.2 Добавление обработчиков событий с помощью `addEventListener`

Более современный и гибкий способ — использовать метод `addEventListener`:

```
let button = document.querySelector('button'); button.addEventListener('click', function() {   
	let heading = document.getElementById('heading');   
	heading.textContent = 'Текст изменён через addEventListener!'; 
});
```

Другие распространённые события:

- **`click`** — клик мыши.
- **`input`** — ввод текста в поле.
- **`submit`** — отправка формы.
- **`mouseover`** — наведение мыши на элемент.

### 6. Создание и удаление элементов

JavaScript позволяет динамически создавать и удалять элементы на странице.

#### 6.1 Создание элемента

Метод `createElement` создаёт новый HTML-элемент:

```
let newParagraph = document.createElement('p'); 
newParagraph.textContent = 'Это новый параграф';  // Добавим его в конец body 
document.body.appendChild(newParagraph);
```
#### 6.2 Удаление элемента

Метод `remove` позволяет удалить элемент:

```
`let heading = document.getElementById('heading'); 
heading.remove();  // Удалит заголовок`
```

Также можно использовать метод `removeChild`, если нужно удалить дочерний элемент:

```
let parent = document.querySelector('div'); 
let child = document.querySelector('p'); parent.removeChild(child);
```


### 7. Пример: Изменение содержимого по клику

Полный пример, в котором меняется текст заголовка при нажатии на кнопку:

`<!DOCTYPE html> 
<html>
<head>   
	<title>Изменение текста</title> 
</head> 
	<body>  
		<h1 id="heading">Исходный заголовок</h1> 
		<p class="text">Это параграф текста.</p> 
		<button>Изменить заголовок</button> 
		 <script>   // Добавляем событие на кнопку   
			 let button = document.querySelector('button');   button.addEventListener('click', function() {    let heading = document.getElementById('heading');     heading.textContent = 'Заголовок изменён!';   }); </script>  
	</body> 
</html>`

### 8. Задания для практики:

1. **Изменение стиля**: Сделайте так, чтобы при клике на кнопку текст параграфа менял цвет на зелёный.
2. **Добавление элементов**: Напишите код, который будет добавлять новый элемент списка каждый раз при нажатии на кнопку.
3. **Обработчики событий**: Реализуйте форму с полем ввода и кнопкой, при нажатии на которую выводится введённый текст в новый элемент на странице.
   
   
   
### 9 Условные операторы (if, else if, else)

Условные операторы позволяют выполнить определённый блок кода в зависимости от истинности или ложности выражения.

#### 9.1 Оператор `if`


`let age = 20;  if (age >= 18) {   console.log('Ты совершеннолетний'); }`

#### 9.2 Оператор `else if`

Если первое условие ложное, можно добавить дополнительную проверку с `else if`:


`let age = 15;  if (age >= 18) {   console.log('Ты совершеннолетний'); } else if (age >= 13) {   console.log('Ты подросток'); }`

9.3 Оператор `else`

Блок `else` выполняется, если все предыдущие условия ложные:


`let age = 10;  if (age >= 18) {   console.log('Ты совершеннолетний'); } else {   console.log('Ты ещё ребёнок'); }`

### 10. Операторы сравнения и логические операторы

#### 10.1 Операторы сравнения

- **`==`** — сравнение без учёта типа.
- **`===`** — строгое сравнение с учётом типа.

Пример:
$$
cons$ole.log(5 == '5');   // true (сравнение значений без учёта типа) 
console.log(5 === '5');  // false (разные типы данных)`
$$
#### 10.2 Логические операторы

- **`&&`** (логическое И) — оба условия должны быть истинны:
    
    `let a = true, b = false; console.log(a && b);  // false`
    
- **`||`** (логическое ИЛИ) — хотя бы одно условие должно быть истинным:
    
    `console.log(a || b);  // true`
    
- **`!`** (логическое НЕ) — инвертирует значение:
        
    `console.log(!a);  // false`
    

### 11. Оператор `switch`

Оператор `switch` используется для выбора одного из нескольких вариантов на основе значения переменной.

$$
let fruit = 'яблоко';
switch (fruit) {   
	case 'яблоко': 
		console.log('Это яблоко');     
		break;   
	case 'банан':     
		console.log('Это банан');     
		break;   
	default:     console.log('Неизвестный фрукт'); }
$$

- **`break`** прерывает выполнение, чтобы последующие случаи не проверялись.
- **`default`** — выполняется, если ни один из случаев не совпал.

### 12. Циклы

Циклы используются для многократного выполнения блока кода.

#### 12.1 Цикл `for`

Цикл `for` используется, когда известно количество итераций:

$$
for (let i = 0; i < 5; i++) {   
	console.log(i);  // Выведет 0, 1, 2, 3, 4 
}
$$

#### 12.2 Цикл `while`

Цикл `while` повторяет выполнение кода, пока условие истинно:

$$
let i = 0; while (i < 5) {   
console.log(i);  // Выведет 0, 1, 2, 3, 4   i++; 
}
$$

#### 12.3 Цикл `do...while`

Цикл `do...while` выполняется хотя бы один раз, даже если условие изначально ложно:

$$let i = 0; do {   
	console.log(i);  // Выведет 0, 1, 2, 3, 4   i++; 
	} 
	while (i < 5);
$$

### 13. Функции

Функции позволяют структурировать код и переиспользовать его. Функция может принимать аргументы и возвращать результат.

#### 13.1 Обычные функции

$$
function greet(name) {
   return 'Привет, ' + name; 
}  
   console.log(greet('Иван'));  // Выведет "Привет, Иван"
$$
#### 13.2 Функции с параметром по умолчанию

Параметры могут иметь значения по умолчанию, если они не переданы:
$$
function greet(name = 'Гость') {   
	return 'Привет, ' + name; 
}  
	console.log(greet());  // Выведет "Привет, Гость"
$$
#### 13.3 Стрелочные функции

Это более краткий способ записи функций.
$$
const greet = (name) => 'Привет, ' + name; 
console.log(greet('Мария'));  // Выведет "Привет, Мария
$$
### 14. Таймеры: `setTimeout` и `setInterval`

Таймеры позволяют выполнять код с задержкой или через определённые промежутки времени.

#### 14.1 `setTimeout`

`setTimeout` выполняет функцию через определённое количество миллисекунд.
$$
setTimeout(() => {  
 console.log('Привет через 2 секунды'); 
 }, 2000);  // 2000 миллисекунд = 2 секунды
$$
#### 14.2 `setInterval`

`setInterval` выполняет функцию периодически через заданный интервал времени.
$$
let count = 0; 
const intervalId = setInterval(() => {  
	count++;   
	console.log('Прошло ' + count + ' секунд');      
	if (count === 5) {   
	  clearInterval(intervalId);  // Остановить таймер после 5 секунд   |
	} }, 1000);  // 1000 миллисекунд = 1 секунда
$$
### 15. События и Event Listeners

JavaScript позволяет реагировать на действия пользователя, такие как нажатия кнопок, ввод текста или движения мыши.

#### 15.1 Пример добавления события

Чтобы добавить обработчик события (например, клик по кнопке), используется метод `addEventListener`:

$$
<button id="myButton">Нажми меня</button>  
<script>  
	let button = document.getElementById('myButton');      button.addEventListener('click', () => {    
		console.log('Кнопка была нажата');   }
	); 
</script>
$$

В этом примере при каждом клике на кнопку в консоль выводится сообщение "Кнопка была нажата".

#### 15.2 Введение в события

События — это действия пользователя (например, клик, прокрутка или ввод). Для добавления обработчиков событий можно использовать различные типы событий, например:

- `click` — нажатие мышью.
- `input` — изменение значения в поле ввода.
- `submit` — отправка формы.
- `keydown` — нажатие клавиши на клавиатуре.

Пример обработки события `input`:

<input type="text" id="nameInput" placeholder="Введите своё имя"> 
<script>   
	let input = document.getElementById('nameInput');      input.addEventListener('input', () => { 
		console.log('Вы ввели: ' + input.value);   
	}); 
</script>

### 16. Задания для практики

1. **Циклы**: Напишите цикл, который выводит числа от 1 до 10.
2. **Условные операторы**: Создайте функцию, которая проверяет возраст и выводит сообщение в зависимости от того, достиг ли пользователь совершеннолетия.
3. **Таймеры**: Реализуйте простой таймер, который каждую секунду выводит сообщение в консоль, а через 10 секунд останавливается.
4. **Event Listeners**: Добавьте событие на кнопку, которое меняет текст на странице при клике.
   
   
### 17. Промисы (Promises)

**Промис** — это объект, который представляет результат асинхронной операции: успешное выполнение (результат) или ошибку.

#### Создание и Структура Промиса

Промис создается с помощью конструктора `Promise`, принимающего функцию с двумя аргументами: `resolve` (выполнено) и `reject` (отклонено).


```
const myPromise = new Promise((resolve, reject) => {
  const success = true;
  
  if (success) {
    resolve("Операция выполнена успешно!");
  } else {
    reject("Произошла ошибка.");
  }
});

```

#### Обработка Промисов: `then` и `catch`

Чтобы получить результат, используют методы `.then()` и `.catch()` для обработки успешных и неудачных состояний промиса:


```
myPromise
  .then(result => console.log(result)) // Выводит "Операция выполнена успешно!"
  .catch(error => console.error(error)); // Выводит ошибку, если `reject`

```


---

### 18. Асинхронные Функции (async/await)

**Асинхронные функции** упрощают работу с асинхронными операциями, позволяя писать асинхронный код, который выглядит как синхронный. Ключевые слова `async` и `await` делают код более читаемым.

#### Синтаксис async/await

Функция, объявленная с `async`, всегда возвращает промис. Внутри функции можно использовать `await` для "ожидания" выполнения промисов:

```
async function fetchData() {
  try {
    const response = await fetch('https://example.com/data');
    const data = await response.json(); // Ждём, пока данные придут
    console.log(data);
  } catch (error) {
    console.error('Ошибка:', error); // Обрабатываем ошибку
  }
}

fetchData();

```

#### Преимущества async/await

- **Упрощает код**: Отсутствие цепочки `.then()`, особенно полезно для обработки нескольких последовательных асинхронных операций.
- **Обработка ошибок**: Можно использовать `try...catch`, что делает обработку ошибок проще.

---

### 19. Стрелочные Функции (Arrow Functions)

Стрелочные функции — это сокращённый синтаксис функций в JavaScript, который позволяет создавать функции быстро и удобно. Они объявляются с помощью `=>` и не имеют собственного контекста `this`, что делает их удобными для использования в колбэках.

#### Синтаксис стрелочных функций

- **Однострочная функция**: Если функция состоит из одного выражения, скобки `{}` и ключевое слово `return` можно опустить.
    
		const greet = (name) => `Привет, ${name}`;
		console.log(greet("Иван")); // Выводит "Привет, Иван"

    
- **Многострочная функция**: Если тело функции сложнее, используют фигурные скобки `{}` и `return`, если нужно вернуть значение.
    
    
    `const add = (a, b) => {   const sum = a + b;   return sum; }; console.log(add(2, 3)); // Выводит 5`
    

### Основные моменты использования стрелочных функций

- **Нет собственного контекста `this`**: Стрелочные функции наследуют `this` от родительской функции.
- **Не имеют `arguments`**: Для обращения к аргументам следует явно передавать их в параметры функции.

---

### 20. Задания для практики

1. **Работа с промисами**: Создайте промис, который завершится через 2 секунды и выведет сообщение "Выполнено!".
2. **Асинхронная функция**: Напишите асинхронную функцию, которая делает запрос к API и обрабатывает ошибки.
3. **Стрелочные функции**: Используйте стрелочные функции для создания обработчика события на кнопку, который выводит сообщение в консоль.   
### Fetch API: Основы, Виды Запросов и Обработка Ошибок

**Fetch API** позволяет отправлять сетевые запросы и получать ответы от серверов. Используется для работы с HTTP-запросами в JavaScript.

#### 21 Основы Fetch

Для отправки запросов используется метод `fetch()`, который возвращает **Promise**. В общем виде запрос с использованием `fetch` выглядит так:

```
fetch('https://example.com/api')
  .then(response => response.json()) // Получение и обработка JSON-ответа
  .then(data => console.log(data)) // Работа с данными
  .catch(error => console.error('Ошибка:', error)); // Обработка ошибок

```

### 22. Основные Виды Запросов с Fetch

#### 22.1 GET-запрос

GET-запрос используется для получения данных с сервера. Он отправляется по умолчанию, если метод не указан.


```
fetch('https://example.com/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Ошибка:', error));

```
#### 22.2 POST-запрос

POST-запросы применяются для отправки данных на сервер, например, для создания или обновления информации.


```
fetch('https://example.com/api/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Иван',
    age: 25
  })
})
  .then(response => response.json())
  .then(data => console.log('Успешно:', data))
  .catch(error => console.error('Ошибка:', error));

```

#### 22.3 PUT-запрос

PUT-запросы обычно используются для обновления существующих данных на сервере.


```
fetch('https://example.com/api/data/1', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Иван',
    age: 26
  })
})
  .then(response => response.json())
  .then(data => console.log('Данные обновлены:', data))
  .catch(error => console.error('Ошибка:', error));

```


#### 22.4 DELETE-запрос

DELETE-запросы применяются для удаления данных с сервера.

```
fetch('https://example.com/api/data/1', {
  method: 'DELETE'
})
  .then(response => {
    if (response.ok) {
      console.log('Данные удалены');
    } else {
      throw new Error('Не удалось удалить данные');
    }
  })
  .catch(error => console.error('Ошибка:', error));

```
### 23. Обработка Ошибок

Ошибки могут возникать по разным причинам — отсутствие интернета, некорректный URL, ошибка на сервере и др. Для обработки таких ситуаций:

#### 23.1 Проверка статуса ответа

Даже если сервер возвращает ошибку (например, 404 или 500), запрос считается успешным, поэтому нужно дополнительно проверять статус ответа.


```
fetch('https://example.com/api/data')
  .then(response => {
    if (!response.ok) { // Проверка на ошибки
      throw new Error(`Ошибка: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Ошибка:', error));

```

#### 23.2 Обработка сетевых ошибок

Поскольку `fetch` возвращает ошибку `TypeError` для сетевых проблем, их можно отловить с помощью `catch`:

````
fetch('https://incorrect-url.com/api')
  .then(response => response.json())
  .catch(error => {
    console.error('Ошибка сети:', error.message);
  });
````

### 24. Асинхронная функция с Fetch

Для удобства `fetch` можно использовать с `async/await`, чтобы сделать код более читаемым.

```
async function fetchData() {
  try {
    const response = await fetch('https://example.com/api');
    if (!response.ok) {
      throw new Error(`Ошибка: ${response.status}`);
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Ошибка:', error);
  }
}

fetchData();
```
### 25. Частые ошибки при работе с Fetch

- **Ошибка сети**: Ошибка возникает, если сервер недоступен.
- **Ошибка 404**: Ресурс не найден.
- **Ошибка 500**: Внутренняя ошибка сервера.
- **Ошибки CORS** (Cross-Origin Resource Sharing): Сервер может не разрешать запросы из других доменов.

Для обработки этих ошибок применяются `catch` и проверки кода ответа.

### 26. Задание для практики

1. **GET-запрос**: Напишите функцию для получения данных от сервера и их отображения на странице.
2. **POST-запрос**: Создайте форму с кнопкой, отправляющую данные на сервер через POST.
3. **Асинхронный запрос с обработкой ошибок**: Реализуйте функцию для получения данных с сервера с проверкой статуса и выводом ошибок.